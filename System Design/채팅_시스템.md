# 채팅 시스템

## 문제

### 채팅 시스템을 설계하라

## 1단계

### 할 수 있는 질문

<details>
    <summary>펼쳐보기</summary>

1. 1:1 채팅 앱인지, 그룹 채팅 앱인지?
2. 어떤 디바이스를 지원하는지?
3. 처리해야 하는 트래픽의 규모는?
4. 그룹 채팅방의 인원 제한은?
5. 중요 기능은?
6. 채팅 메시지의 길이 제한은?
7. 종단 간 암호화가 필요한지?
8. 채팅 이력은 얼마나 오래 저장해야 하는지?

</details>

### 면접관의 답변 예시

<details>
    <summary>펼쳐보기</summary>

1. 둘다 지원
2. 모바일, 웹 둘다 지원
3. DAU 기준 5천만 명 처리
4. 100명
5. 1:1 채팅, 그룹 채팅, 사용자 접속상태 표시 지원 / 텍스트 채팅만 가능
6. 100,000자
7. 필요없음
8. 영구 저장

</details>

### 답변으로 정리된 요구사항

<details>
    <summary>펼쳐보기</summary>

1. 응답지연이 낮은 일대일 채팅 기능
2. 최대 100명까지 참여 가능한 그룹 채팅 기능
3. 사용자의 접속상태 표시 기능
4. 다양한 단말 지원
5. 푸시 알림

</details>

## 2단계

### 채팅 서비스에 필요한 기능

- Client들로부터 메시지 수신
- 메시지 수진자 결정 및 전달
- 수신자가 접속상태가 아닌 경우 해당 메시지 보관

### HTTP

<p align="center">
    <img src="../resources/chatting_process.png" width=600>
</p>

- 채팅을 시작하려는 클라이언트는 `네트워크 통신 프로토콜`을 사용하여 서비스에 접속
- 페이스북 등의 서비스는 초기에 `HTTP 프로토콜` 사용
  - 채팅 서비스에 HTTP 프로토콜로 연결한 다음, 메시지를 보내어 수신자에게 해당 메시지를 전달하라고 알림
- `keep-alive` 헤더 사용
  - 클라이언트와 서버 간의 연결을 계속 유지
  - hand-shake 횟수를 줄일 수 있음
- 단점
  - HTTP는 클라이언트가 연결을 만드는 프로토콜
  - 서버에서 클라이언트로 임의 시점에 메시지를 보내는게 어려움

### Polling

<p align="center">
    <img src="../resources/polling.png" width=600>
</p>

- 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 물어보는 방법
- 폴링 비용과 폴링 주기는 반비례 관계
- 단점
  - 서버에게 불필요한 요청을 보냄
  - 실시간성이 떨어짐

### Long Polling

<p align="center">
    <img src="../resources/long_polling.png" width=600>
</p>

- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결 유지
- 단점
  - Sender와 Receiver가 같은 채팅 서버에 접속하게 되지 않을 경우
    - Sender는 메시지 송신
    - Receiver는 해당 서버와 Long Polling 연결이 돼있지 않음
  - 서버 입장에서 클라이언트의 연결에 대한 정보를 알 방법이 없음
  - 여전히 비욜적
    - 타임아웃이 발생할 때마다 다시 서버에 접속해야 함

### Websocket (✓)

<p align="center">
    <img src="../resources/websocket.png" width=600>
</p>

- 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
- `양방향 통신`
- 최초 접속 시엔 HTTP 프로토콜 (HTTP Header 사용)
- 웹소켓을 위한 별도의 포트는 없고, `기존 포트를 사용`(80, 443)
  - 방화벽이 있는 환경에서도 잘 동작
- 프레임으로 구성된 `메시지`라는 논리적 단위로 송수신
  - 메시지에 포함될 수 있는 교환 가능한 메시지: `텍스트`와 `바이너리`
- 설계뿐 아니라 구현도 단순 및 직관적

### 개략적 설계안

- 무상태 서비스
  - 로그인, 회원가입, 사용자 프로필 표시 등을 처리
  - 로드밸런스 뒤에 위치 
    - 특정 서비스로 라우팅 될 수 있게 설계가 필요
    - `서비스 탐색` 서비스 (클라이언트가 접속할 `채팅 서버의 DNS 호스트명`을 클라이언트에게 알려줌)
- 상태 유지 서비스
  - 채팅 서비스
  - 각 클라이언트가 채팅 서버와 독립적인 네트워크 연결 유지
  - `서비스 탐색` 서비스와 협력
    - 특정 서버로 부하가 몰리지 않게 적절하게 분배
- 제 3자 연동 서비스
  - 푸시알람 서비스와 연동
- 규모 확장성
  - 서버 한대로 모든 연결을 처리하면 확장 및 SPOF 문제가 발생함

<p align="center">
    <img src="../resources/chatting_system_1.png" width=600>
</p>

- 채팅 서버
  - 클라이언트 사이에 메시지를 중계하는 역할
- 접속 상태 서버
  - 사용자의 접속 여부 관리
- API 서버
  - 로그인, 회원가입, 프로필 변경 등 그 외 나머지 전부 처리
- 알림 서버
  - 푸시 알림 전송
- 키-값 저장소
  - 채팅 이력 보관

### DB는 무엇을 쓸 것인가?

- 일반 데이터
  - 사용자 프로필, 설정, 친구 목록 등
  - 안정성을 보장하는 `RDB`
  - 확장 시에는 샤딩이나 레플리케이션을 고려
- 채팅 이력
  - 많은 데이터 양
  - 비교적 최근 데이터만 조회
  - 무작위 조회도 있음
  - 읽기:쓰기 비율이 `1:1`
  - 읽기 지연시간이 낮은 `NoSQL`의 `Key-Value 모델`이 적합
  - Discord → `Cassandra` 
  - Facebook → `HBase`

### 데이터 모델

- 1:1 채팅과 그룹 채팅을 위한 메시지 테이블

<p align="center">
    <img src="../resources/chatting_data_model.png" width=700>
</p>

- 1:1 채팅
  - message_id가 PK
- 그룹 채팅
  - channel_id와 message_id가 PK (`복합키`)
  - channel_id는 `파티션 키`로도 사용 가능
- message_id
  - 메시지 식별자
  - 정렬 가능해야 하며, 시간 순서와 일치해야 함
  - 전역 ID 생성기 사용
    - [Snowflake](https://github.com/lcomment/development-recipes/blob/main/System%20Design/분산_시스템을_위한_유일_ID_생성기.md)
  - `지역적 순서 번호 생성기` 사용
    - 같은 채팅 세션 안에서만 순서가 보장되면 됨
    - 전역 ID 생성기보다 구현하기 쉬움

## 3단계

### 서비스 탐색


