# 데이터베이스

## I. RDB

### 특징

- 자료를 Table, Row, Column으로 표현
- 명확한 데이터 구조(스키마) 보장 → `데이터 무결성`
- 관계는 데이터 `중복 없이` 한번만 저장
- SQL을 활용하여 여러 Table 간 데이터를 합칠 수도 있음

### 단점

- 스키마로 인해 데이터가 유연하지 못함
- 시스템의 규모가 커질 경우 `Join문이 많은 복잡한 쿼리`가 만들어질 수 있음
- 수직적 확장(Scale-Up)만 지원 → `비용 문제` 발생

## +) MySql, PostgreSql, Oracle 비교하기

### 1. 성능

<details>
   <summary>설명 보기</summary>

- MySQL
  - 읽기 중심의 작업에서 빠르고 효율적
  - 많은 사용자가 동시에 데이터베이스에 접근하는 경우, 간단한 쿼리에 대한 빠른 응답 시간을 제공
  - 대규모 웹 사이트와 같은 환경에서 선호
- PostgreSQL
  - 복잡한 쿼리와 대용량 데이터셋에서 우수한 성능을 보여줌
  - 데이터 조작 및 분석을 필요로 하는 경우, PostgreSQL의 최적화된 Query Planner와 다양한 인덱싱 기능이 큰 장점이 됨
- Oracle
  - 대규모 엔터프라이즈 애플리케이션을 위해 설계되었음
  - 고급 최적화 기능을 통해 높은 성능을 유지
  - 복잡한 트랜잭션과 많은 동시 연결을 처리할 수 있는 능력
  - 금융 및 대형 기업 시스템에서 많이 사용

</details>

### 2. 기능

<details>
   <summary>설명 보기</summary>

- MySQL
  - 기본적인 SQL 기능을 제공하지만, PostgreSQL이나 Oracle에 비해 복잡한 기능 부족
- PostgreSQL
  - JSONB, 배열 데이터형, 고급 인덱싱과 같은 다양한 기능을 지원하여 복잡한 데이터 구조를 다룰 수 있음
  - 데이터베이스를 더욱 유연하게 사용할 수 있게 해줌
- Oracle
  - 파티셔닝, 병렬 처리, 고급 보안 기능 등 다양한 고급 기능을 제공
  - 대규모 데이터베이스 관리 및 트랜잭션 처리에서 뛰어난 성능을 보여줌
  - 엔터프라이즈 환경에서의 안정성과 유연성이 필요할 때 적합

</details>

### 3. 확장성

<details>
   <summary>설명 보기</summary>

- MySQL
  - 중소규모 애플리케이션에 적합
  - 샤딩과 클러스터링을 통해 확장 가능, But 설정이 복잡
  - 대규모 트래픽을 처리하는 데 한계가 있을 수 있음
- PostgreSQL
  - 확장이 용이하며, 대량의 데이터와 사용자 처리 가능
  - 수평 확장을 위해 파티셔닝과 리플리케이션 지원
  - 대규모 애플리케이션에서도 효율적으로 사용 가능
- Oracle
  - 대규모 기업 환경에서 최적화되어 있음
  - 수천 개의 동시 연결과 대규모 데이터베이스를 효율적으로 관리 가능
  - 안정성과 확장성이 중요한 환경에 적합

</details>

### 4. 비용

<details>
   <summary>설명 보기</summary>

- MySQL
  - 오픈 소스이며 무료로 사용 가능
  - 상용 버전은 추가 기능과 지원을 제공하지만, 기본적으로 무료
  - 비용이 중요한 스타트업이나 소규모 프로젝트에 적합
- PostgreSQL
  - 완전히 오픈 소스
  - 기능이 매우 풍부하지만 비용이 발생하지 않음
  - 예산이 한정된 프로젝트에 이상적
- Oracle
  - 상용 라이센스 필요
  - 비용이 높지만 고급 기능과 기술 지원을 제공
  - 대규모 엔터프라이즈 환경에서는 투자할 가치가 충분히 있음

</details>

### 5. 사용 사례

<details>
   <summary>설명 보기</summary>

- MySQL
  - 간단한 CRUD 애플리케이션이나 소규모 웹 애플리케이션에 적합
  - 사용자 수가 많지 않은 경우에도 빠른 성능을 발휘
- PostgreSQL
  - 복잡한 쿼리와 데이터 분석이 필요한 대규모 애플리케이션에 적합
  - 데이터 무결성과 확장성이 중요한 환경에서 특히 유용
- Oracle
  - 대규모 엔터프라이즈 애플리케이션, 복잡한 트랜잭션 관리, 그리고 안정성이 중요한 금융 시스템 등에서 가장 적합

</details>

## II. NoSql

### 특징

- 관계를 정의하지 않음
- `유연`하고 `자유`로운 데이터 구조
  - 다른 구조의 데이터를 같은 컬렉션(collection)에 추가 가능
  - 문서(document)는 json과 비슷한 형태로 가지고 있음
- `데이터 분산` 용이
- Scale Out 가능

## +) 언제 어떤 모델을 사용할까?

### 1. 키-값(Key-Value) 모델

<details>
    <summary>설명 보기</summary>

- 특징
  - 간단한 키-값 쌍으로 데이터 저장
  - 빠른 읽기/쓰기를 위해 최적화되어 있음
  - 구조가 단순하여 큰 데이터셋을 다루기 좋고, 확장성이 뛰어남
- 적합한 사용 사례
  - 사용자 세션
  - 캐시
  - 빠른 조회가 필요한 애플리케이션
- 실사례
  - Redis와 DynamoDB가 대표적인 예
  - 대규모 웹 애플리케이션에서 사용자 세션을 저장하거나, 캐시 데이터 저장에 활용
  - ex. 실시간 채팅 구현에 Redis 사용

</details>

### 2. 문서(Document) 모델

<details>
    <summary>설명 보기</summary>

- 특징
  - JSON, BSON, XML 등의 구조화된 문서 형식으로 데이터 저장
  - 데이터 모델링이 자유로움
  - 여러 필드를 함께 저장하여 개별적인 쿼리보다는 데이터를 전체적으로 조회하기에 유리
- 적합한 사용 사례
  - 제품 정보, 소셜 미디어 포스트, 사용자 프로필 등 동적인 데이터를 다루는 경우
- 실사례
  - MongoDB와 Couchbase가 대표적
  - MongoDB는 전자상거래 웹사이트에서 제품 정보(예: 이름, 설명, 가격)를 저장할 때 유용
  - 각각의 제품은 다양한 속성을 가질 수 있으므로, 문서 모델은 속성 수가 일정하지 않은 데이터를 저장하는 데 적합

</details>

### 3. 컬럼(Column) 모델

<details>
    <summary>설명 보기</summary>

- 특징
  - 행(Row)보다 열(Column) 단위로 데이터를 저장
  - 대규모 데이터 집합에서 특정 열을 조회하거나 분석하는 데 최적화되어 있음
  - 스키마 유연성과 확장성이 뛰어나고, 특정 열의 데이터만 조회하거나 분석할 때 효율적
- 적합한 사용 사례
  - 분석 시스템, 데이터 웨어하우스, 시계열 데이터
- 실사례
  - Cassandra와 HBase가 대표적
  - Cassandra는 시계열 데이터를 처리하는 데 자주 사용됨
  - IoT 센서 데이터나 실시간 로그 데이터와 같은 경우에도 컬럼 모델은 빠르고 효율적인 데이터 검색을 가능하게 함

</details>

### 4. 그래프(Graph) 모델

<details>
    <summary>설명 보기</summary>

- 특징
  - 노드와 엣지(관계)를 통해 데이터를 저장
  - 데이터 간의 관계를 직관적으로 표현 가능
  - 데이터 간의 연결성과 관계성을 분석할 때 유리
- 적합한 사용 사례
  - 소셜 네트워크, 추천 시스템, 경로 탐색
- 실사례
  - Neo4j와 Amazon Neptune이 대표적
  - 소셜 미디어에서 친구 관계와 같은 연결 구조를 빠르게 조회할 수 있어 관계형 데이터베이스보다 효율적
  - 추천 시스템에서도 사용자 간 유사성을 기반으로 관계를 분석하여 맞춤형 추천을 제공 가능

</details>

## +) NoSql의 데이터 중복 문제와 동기화

- 일반적으로 데이터 중복을 허용하여 높은 성능을 확보
- 동일한 데이터를 여러 위치에 저장하게 되어 변경 사항을 동기화해야 하는 문제 발생
- ex. 사용자 프로필 정보를 중복 저장한다고 가정하면, 사용자가 이메일을 업데이트할 때 모든 저장소에 일관된 변경 필요

### 동기화 방법

<details>
    <summary>설명 보기</summary>

- 애플리케이션 레벨에서의 동기화
  - 애플리케이션에서 데이터 수정 시 각 저장소에 `변경 사항을 동기화`하는 방식
  - 개발자가 직접 관리해야 하므로 로직이 복잡해질 수 있지만, 특정 비즈니스 요구에 맞게 구현할 수 있음
- 이벤트 기반 동기화
  - 변경된 데이터가 있는 경우 메시지 큐를 통해 이벤트를 전파하고, 각 저장소가 이벤트를 수신해 데이터를 업데이트
  - 이는 확장성과 성능 면에서 효율적이며, 마이크로서비스 아키텍처에서 자주 사용됨
- 일관성 모델 선택
  - NoSQL 데이터베이스에서 제공하는 최종 일관성(Eventual Consistency) 방식 활용
    - 시간이 지나면 결국 모든 저장소의 데이터가 일관되도록 보장하는 방식
  - 이 방식은 SNS나 쇼핑몰 등 실시간성이 덜 요구되는 환경에서 적합

</details>

## III. 어떤 데이터베이스를 사용할 것인가?

데이터 구조가 안정적이고 무결성이 중요한 경우, RDB가 적합하지만, 다음과 같은 경우 NoSql을 고려하자.

- 아주 낮은 응답 지연시간 요구
- 다루는 데이터가 `비정형`(관계형 데이터가 아님)
- 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 됨
- 아주 `많은 양의 데이터`를 저장할 필요가 있음

## IV. 데이터베이스 다중화

### Master-Slave 구조

- 원본은 주 서버(Master)에, 사본은 부 서버(Slave)에 저장하는 방식
- 주 서버는 Write만, 부 서버는 Read만 책임
  - 부하 분산
  - 읽기 Query를 병렬 처리 가능
  - DB 서버 중 일부가 다운돼도 안정적임
  - 여러 지역에 복제하여 고가용성 유지
- 주 서버가 다운될 경우
  - 부 서버 중 하나가 주 서버가 됨
  - 손실된 데이터를 복구하기 위해 다음과 같은 방법이 있음
    - 복구 스크립트 작성
    - 다중 마스터
    - 원형 다중화

## V. 데이터베이스 규모 확장

### Scale Up의 문제

- 수직적 확장에는 한계가 존재
- SPOF(Single Point Of Failure)로 인한 위험성
- 비용이 많이 듦

### DB의 Scale Out

- `샤딩`이라고 부름
  - 대규모 DB를 샤드라는 작은 단위로 분할하는 기술
  - 모든 샤드는 같은 Schema를 쓰지만, 보관되는 데이터 사이에는 중복이 없음
- 샤딩 전략에 가장 중요한 것은 `샤딩 키` (파티션 키)
  - 샤딩 키를 정할 땐 데이터를 고르게 분산할 수 있도록 하는게 가장 중요
  - 훌륭한 기술이지만 다음과 같은 해결해야 할 문제가 생김

### 샤딩 도입 시 해결해야 할 문제

- 데이터 재샤딩
  - 재샤딩이 필요한 경우
    - 데이터를 적재하는 도중, 현재의 샤드 개수로는 감당하기 힘들 경우
    - 샤드 간 데이터 분포가 균등하지 못할 경우
  - 샤드 키를 계산하는 함수를 변경해야 하며 데이터를 재배치까지 하는 추가 작업이 필요 ([안정 해시](https://github.com/lcomment/development-recipes/blob/main/System%20Design/consistentHash.md))
- 유명인사 문제
  - 핫스팟 키(hotspot key) 문제라고도 불림
  - 특정 샤드에 질의가 집중되어 샤드 불균형이 발생하는 문제
  - 유명인사를 샤드에 고르게 분포시켜야 함
- 조인과 비정규화
  - 데이터베이스를 여러 샤드서버로 쪼개면, 데이터를 조인하기 어려워짐
  - 데이터베이스를 비정규화하여 데이터 중복을 감수해야 함
