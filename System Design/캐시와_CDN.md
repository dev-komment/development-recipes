# 캐시와 CDN

## I. 캐시

: 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소

### 캐시 계층

- 데이터가 잠시 보관되는 곳
- DB보다 훨씬 빠르고, DB의 부하를 줄일 수 있음
- 캐시 계층의 규모를 `독립적`으로 확장 가능

### 캐시 사용 시 유의할 점

- 데이터 갱신이 자주 일어나지 않지만 참조는 빈번하게 일어날 때 사용하자
  - `Eviction`은 꽤 큰 비용을 가진다.
- 어떤 데이터를 캐시에 둘 것인가?
  - 캐시는 `휘발성`이다.
- `TTL`(Time To Live)을 생각하자.
- `일관성`을 어떻게 유지할 것인가?
- `장애`에는 어떻게 대처할 것인가?
  - SPOF에 대처하기 위해 `분산 환경`을 고려하자.
- 캐시의 메모리는 얼마나 크게 잡을 것인가?
  - 캐시가 밀려나버리면 성능이 저하됨
  - 캐시 메모리를 적당히 `과할당` 하자.
- `데이터 방출 정책`은 무엇인가?
  - LRU: 안 쓴지 가장 오래된 데이터 버리기
  - LFU: 사용 빈도가 가장 낮은 데이터 버리기
  - FIFO: 가장 오래된 캐시 버리기

### 캐시 읽기 전략

- Look-Aside
  - 애플리케이션이 캐시에 데이터가 있는지 조회
  - 캐시 미스 시, DB에서 조회
  - 이후 `애플리케이션`이 DB에서 가져온 데이터를 캐시에 저장
- Read-Through
  - 캐시와 데이터베이스를 일렬로 배치
  - 캐시 미스 시, `DB`에서 누락된 데이터 로드 및 캐시에 저장
  - 이 데이터를 애플리케이션에 반환

### 캐시 쓰기 전략

- Write-Through
  - DB와 캐시에 동시 저장
  - 항상 동기화 상태 (일관성 보장)
- Write Back
  - 캐시와 DB 동기화를 비동기하기 때문에 동기화 과정 생략
  - 바로 DB에 저장하지 않고, 모아서 일정 주기 배치 작업으로 저장
- Write Around
  - 데이터를 DB에 직접 기록
  - 읽은 데이터만 캐시에 저장

## II. CDN (Content Delivery Network)

- 정적 컨텐츠를 전송하는 데 쓰이는 지리적으로 분산된 서버의 네트워크
- Static Content에 대하여 캐시 가능
- 요청 경로, Query string, 쿠키, 헤더 등의 정보에 기반하여 HTML 페이지 캐시

### 동작 방식

1. 사용자가 이미지 URL을 통해 이미지에 접근 (이미지 URL은 CDN에서 제공)
2. 이미지가 없는 경우, 원본 서버에 요청하여 파일을 가져옴 (TTL 포함)
3. CDN 서버에서 가져온 파일을 캐싱하고 사용자에게 반환
4. 다른 사용자가 이미지에 대한 요청을 CDN에게 보냄
5. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리

### 사용 시 고려해야 할 사항

- 비용
  - CDN은 서드 파티에 의해 운영됨
  - 데이터 전송 양에 따라 요금을 내야 함
  - 자주 사용되지 않는 컨텐츠에 대해 캐싱하지 말아야 함
- 적절한 만료 시한 설정
  - 너무 길면 정합성의 문제가 있음
  - 너무 짧으면 원본 서버에 빈번히 접속해야 함
- CDN 장애에 대한 대처 방안
  - CDN 자체가 죽었을 경우에 애플리케이션이 어떻게 동작할지 고려
  - CDN에서 일시적으로 응답이 오지 않을 경우 원본 서버로부터 가져오도록 구성
- 컨텐츠 무효화 방법
  - 만료되지 않은 컨텐츠를 제거하는 방법을 고려하자.
  - CDN 서비스 사업자가 제공하는 API
  - 오브젝트 버저닝: URL의 인자를 통해 컨텐츠의 다른 버전을 서비스하도록 하는 것
